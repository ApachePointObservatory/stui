<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>TUI:Scripts:Scripting Tutorial:Refinements</title>
</head>
<body>

<h2>Refinements</h2>

<p>Adding a few refinements to the DISCals script makes a script worth adapting for your own uses.

<p>The improvements are as follows:

<dl>
	<dt>Better feedback
	
	<dd>The original DISCals script opened the DIS Expose window to give feedback, which is clumsy. Fortunately this easy to fix by borrowing the <code>ExposeStatusWdg</code>, the feedback widget used by exposure windows. <code>ExposeStatusWdg</code> updates its own displays, so it is very easy to use!
	
	<dd>The original DISCals script also gave misleading feedback, because there was no hint that multiple sequences were going to occur. This version takes advantage of the "startNum" and "totNum" arguments to <code>disExpose</code> to report how many exposures truly remain in the script. Doing this requires computing the total number of exposures in advance, which requires looping through the data twice: first to count the number of exposures, then to execute the exposures.
	
	<dt>Proper file numbering
	
	<dd>File numbering should obey the "Seq by File" preference. You could fix this by reading the sequence number preference manually, but the <code>formatExpCmd</code> function in the instrument exposure model takes care of this for you and also handles the details of formatting.
	<b><code>formatExpCmd</code> is the recommended way to generate exposure commands for any instrument.</b>
	
	<dt>Support for debug mode
	
	<dd>Adding sr.debug = False to the initialization lets you easily toggle this value when you want to debug your script. In debug mode, the script only pretends to operate, it doesn't actually talk to the hub or any instruments. Your script can also read this value, which is useful for providing fake data (as you'll see later in the the "Get Info" lesson).
	
	<dt>Define your script as a class
	
	<dd>If your script needs initialization or cleanup, write it as a class. This allows you to easily pass data between the various functions. Fortunately, conversion is very easy:
	<ul>
		<li>Indent everything one level
		<li>Add <code>class ScriptClass(object):</code> to the beginning
		<li>Change <code>def init(sr)</code> to <code>def __init__(self, sr)</code> (there are two underscrores on either side of "init"; it may look funny, but it's standard python)
		<li>Change <code>def run(sr)</code> to <code>def run(self, sr)</code> and the same for all other functions.
	</ul>

</dl>

<p>The resulting script still has no provision for user input, but often that is fine. We'll deal with user input in the <a href="UserInput.html">next lesson</a>.

<h2><a name="NiceDISCals"></a>NiceDISCals script</h2>

<p><b>As always, get permission to use DIS before commanding it.</b>

<hr>

<pre>
import RO.Wdg
import Tkinter
import TUI.Inst.ExposeModel as ExposeModel
from TUI.Inst.ExposeStatusWdg import ExposeStatusWdg

class ScriptClass(object):
    """Take a series of DIS darks with user input.
    """
    def __init__(self, sr):
        """Display exposure status and a few user input widgets.
        """
        # if True, run in debug-only mode (which doesn't DO anything, it just pretends)
        sr.debug = False

        expStatusWdg = ExposeStatusWdg(
            master = sr.master,
            instName = "DIS",
        )
        expStatusWdg.grid(row=0, column=0, sticky="w")
        
        wdgFrame = Tkinter.Frame(sr.master)
     
        gr = RO.Wdg.Gridder(wdgFrame)
        
        self.expModel = ExposeModel.getModel("DIS")
    
        timeUnitsVar = Tkinter.StringVar()
        self.timeWdg = RO.Wdg.DMSEntry (
            master = wdgFrame,
            minValue = self.expModel.instInfo.minExpTime,
            maxValue = self.expModel.instInfo.maxExpTime,
            isRelative = True,
            isHours = True,
            unitsVar = timeUnitsVar,
            width = 10,
            helpText = "Exposure time",
        )
        gr.gridWdg("Time", self.timeWdg, timeUnitsVar)
        
        self.numExpWdg = RO.Wdg.IntEntry(
            master = wdgFrame,
            defValue = 1,
            minValue = 1,
            maxValue = 999,
            helpText = "Number of exposures in the sequence",
        )
        gr.gridWdg("#Exp", self.numExpWdg)
        
        wdgFrame.grid(row=1, column=0, sticky="w")
        
    def run(self, sr):
        """Take a series of DIS darks"""
        expType = "dark"
        expTime = self.timeWdg.getNum()
        numExp = self.numExpWdg.getNum()
    
        fileName = "dis_" + expType
        
        if expTime &lt;= 0:
            raise sr.ScriptError("Specify exposure time")
    
        cmdStr = self.expModel.formatExpCmd(
            expType = expType,
            expTime = expTime,
            fileName = fileName,
            numExp = numExp,
        )
    
        yield sr.waitCmd(
            actor = "disExpose",
            cmdStr = cmdStr,
            abortCmdStr = "abort",
        )
</pre>

<hr>

<p>Comments:
<ul>
	<li>This is the first script that displays any widgets. In this case it is just one widget, and one that is smart enough to take care of its own display. But the pattern is always the same:
	<ul>
		<li>Use "sr.master" as the master, or parent, widget. This is an empty frame intended for your script's widgets. It appears above the status bar and control buttons.
		<li>Grid or pack widgets to make them show up. Never mix gridding and packing in the same master widget; it usually causes Tk to go into an infinite loop.
		<li>To pass data between <code>__init__</code>, <code>run</code> and <code>end</code>, use <code>self</code>, as in <code>self.expModel =...</code>.
	</ul>
	<li>Every instrument has its own exposure model, with its own <code>formatExpCmd</code> function. Simply call TUI.ExposeModel.getModel(<i>instName</i>) to get it.
</ul>

</body>
</html>
